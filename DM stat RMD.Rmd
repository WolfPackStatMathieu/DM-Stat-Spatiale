---
title: "DM Introduction à la statistique spatiale"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, results='hide',error=TRUE,eval = FALSE)
```


---

```{r}
###Création de notre environment de travail
#Installation des packages
install.packages("sf")
install.packages("spdep")
#Chargement des packages
library(dplyr)
library(sf)
library(spdep)
library(RColorBrewer)
library(leaflet)

###Import des données
#Données carroyées pour la ville de Bordeaux
bordeaux <- st_read("U:/Eleves/Cartographie/Evaluation/Villes_donnees_carroyees/bordeaux.gpkg")

#Récupération du fond de communes et filtrage pour extraire les données relatives à Bordeaux
fond_communes <- st_read("U:/Eleves/Cartographie/Fonds_carte/France_metro/commune_francemetro_2021.shp", options = "ENCODING=UTF8")

fond_communes_bordeaux <- fond_communes %>% 
  filter(libelle=="Bordeaux")

```



### Exercice

En reprenant la méthodologie adoptée au TP6, vous étudierez s’il existe un phénomène d’autocorrélation
spatiale associé au revenu moyen winsorisé ou à la part de ménages pauvres (au choix). L’analyse se fera
sur données carroyées de 200m de côté. Vous travaillerez sur une grande ville (par exemple, Rennes, Lyon,
Lille, Toulouse, Nice, Bordeaux ou autre grande ville qui vous intéresse).

1. Vous commencerez par créer votre variable d’étude : le revenu moyen winsorisé peut être mesuré en
divisant la somme des revenus winsorisés par le nombre d’individus. Si vous travaillez sur la part de
ménages pauvres, il faudra également créer cet indicateur.

```{r}
#Nous avons choisi le revenu moyen winsorisé
bordeaux$revenu_moyen_winsorise <- bordeaux$Ind_snv/bordeaux$Ind
```

2. Vous représenterez ces données carroyées en superposant le fond de la commune. Les carreaux
dépassent-ils les frontières communales ? Si oui, quel intérêt y a-t-il à cela ?
```{r}
###On applique la fonction plot() en utilisant st_geometry() à l'intérieur 
#En effet, si on applique la fonciton plot() seule, on obtiendrait autant de cartes que de variables
#C'est pourquoi nous représentons une seule variable, en l'occurence geometry, variable à lquelle correspodnent les coordonnées

#Dans l'ordre des lignes, nous procédons à la 
#1. Représentation des données carroyées pour Bordeaux
#2. Superposition du fond de commune pour avoir les frontières
#2. Ajout de la variable d'intérêt 
plot(st_geometry(bordeaux))
plot(st_geometry(fond_communes_bordeaux), add=TRUE)
plot(bordeaux["revenu_moyen_winsorise"], add=TRUE)

###Effectivement, les carreaux dépassent les frontières communales 
#Pour rappel, nous travaillons sur des données carroyées de 200m de côté : la construction de ce type de zonage répond au problème dit Modifiable Areal Unit Problem (MAUP) qui interroge l'échelle et le zonage choisis
#Cependant ce découpage très fin soulève la question du secret statistique 
#C'est pourquoi nous travaillons sur des données winsorisées (en question 1)

#En revanche, la frontière communale répond à un découpage administratif
#Par construction, le traitement statistique des données carroyées (et winsorisées) ne prend pas en compte le découpage humain des communes
```



3. Vous étudierez ensuite s’il existe un phénomène d’autocorrélation spatiale. Vous utiliserez l’ensemble
des indicateurs vus en TP, évidemment le I de Moran mais également les indicateurs d’autocorrelation
locaux (LISA). Vous testerez pour ces derniers leur significativité. Vous discuterez également des
résultats en fonction de la notion de voisinage.

a. Dans un premier temps, nous allons comparer la distribution réelle issue de notre jeu de données avec une distribution aléatoire 
```{r}
###Création de la variable à distribution aléatoire 
bordeaux<-bordeaux %>% 
  mutate(revenu_moyen_winsorise_alea = sample(revenu_moyen_winsorise))

###Visualisation 
plot(bordeaux["revenu_moyen_winsorise"])
plot(bordeaux["revenu_moyen_winsorise_alea"])

###La comparaison des deux cartes semble indiquer un phénomène d'autocorrélation spatiale, qui serait positif

###Pour aller plus loin, nous pouvons procéder à cette même comparaison en utilisant d'autres méthodes de discrétisation 
#Méthode quantile
plot(bordeaux["revenu_moyen_winsorise"], breaks = "quantile")
plot(bordeaux["revenu_moyen_winsorise_alea"], breaks = "quantile")

#Méthode Jenks
plot(bordeaux["revenu_moyen_winsorise"], breaks = "jenks")
plot(bordeaux["revenu_moyen_winsorise_alea"], breaks = "jenks")

#Les différentes cartes obtenues convergent également vers l'hypothèse d'une autocorrélation spatiale

#MAPVIEW blbla

library(mapview)

mapview(
  bordeaux,
  z=c("revenu_moyen_winsorise"),
  alpha.regions=0.35,
  layer.name="Revenu_moyen_winsorisé",
  label="libelle"
)
```

b. Nous procédons maintenant à la création d'une matrice de voisinage en utilisant la notion de contiguïté : deux territoires identifiés seront dits voisins si leurs carrés représentatifs sont conitgus. Cela nous permettra d'utiliser le diagramme de Moran pour évaluer la présence d'autocorrélation spatiale
```{r}
###Extraction des voisins de chaque entité 
#On utilise par défaut la contiguité Queen 
voisins <- poly2nb(bordeaux, queen=TRUE)

#On prend connaissance de l'objet créé pour s'assurer de sa cohérence 
str(voisins)
summary(voisins)

#Nous obtenons bien une liste pour les 758 entités géographiques définies par les données carroyées 
#Les sorties nous permettent par exemple d'identifier la distribution du nombre de voisin(s), qui est la suivante : 
#Nombre de voisins :  0 | 1 | 2 |  3 |  4 |  5 |  6  | 7  | 8 
#Nombre d'entité géographique correspondant :  12 | 17 | 29 | 55 | 36 | 66 | 84 | 108 | 351 

###Transformation en matrice de pondération pour donner un poids égal à chaque voisin
#On inclut les entités sans voisin avec l'argument zero.policy = TRUE
ponderation <- nb2listw(voisins, zero.policy = TRUE)

#Nous obtenons bien une liste de trois éléments : 
#1. Le style de la matrice qui correspond à  pour poids
#2. La liste des voisins 
#3. La liste des poids 

#On vérifie que la somme des pondérations est bien égale à 1 pour chaque pondération
(all(sapply(ponderation$weights, sum) == 1))

#Nous obtenons FALSE, mais en faisant le str on s'aperçoit que la somme des weights est bien égale à 1 pour chaque pondération, sauf dans le cas où il n'y a pas de voisins
str(ponderation$weights)

###Diagramme de Moran 
#On créé une nouvelle variable revenu_moyen_winsorise_STD qui correspond à notre variable d'étude centrée et réduite, et que l'on ajoute à notre fond bordelais
bordeaux <- bordeaux %>%
  mutate(revenu_moyen_winsorise_STD = scale(revenu_moyen_winsorise))

mean(bordeaux$revenu_moyen_winsorise_STD)
sd(bordeaux$revenu_moyen_winsorise_STD)
#Nous obtenons une variance égale à 1 et une moyenne très très proche de 0

#Diagramme de Moran, établi à partir de la variable centrée réduite : ATTENTION SOUCI DIMNAME
moran.plot(
  as.numeric(bordeaux$revenu_moyen_winsorise_STD),
  listw = ponderation,
  xlab = "Revenus moyens winsorisés par entité géographique (données carroyées)",
  ylab = "Moyenne des revenus des voisins",
  main = "Diagramme de Moran"
)

#On observe une concentration des observations au sein des deux cadrans suivants : 
#Cadran high-high (en haut à droite), il y a donc beaucoup d'entités géographiques au revenu moyen (winsorisé) élevé et dont les voisins ont aussi un tel revenu élevé 
#Cadran low-low (en bas à gauche), qui renvoie aux entités géographiques avec un faible revenu moyen (winsorisé) et entourés de voisins avec également des revenus faibles
#Les observations sont relativement alignées sur la diagonale, ce qui indique un phénomène d'autocorrélation spatiale positive
```

b. Nous allons maintenant construire le I de Moran 
```{r}
#On utilise l'argument randomisation = TRUE pour comparer à la distribution aléatoire
#On contraint l'argument zero.policy = TRUE pour assigner la valeur zéro aux entités sans voisin
moran.test(bordeaux$revenu_moyen_winsorise_STD, ponderation, randomisation = TRUE, zero.policy = TRUE)

#Nous obtenons une valeur approximative de 0.62 pour le I de Moran, ce qui est assez élevé
#La p-valeur est quant à elle très faible (< 2.2e-16)
#On rejette donc l'hypothèse nulle (à laquelle correspond un I de Moran nulle)
#Cela confirme nos premières intuitions de phénomène d'autocorrélation spatiale assez importante
```

b. LISA - Local Indicators of Spatial Association
```{r}
###Création des LISA
bordeaux_lisa <- spdep::localmoran(bordeaux$revenu_moyen_winsorise, ponderation, zero.policy = TRUE)

###Etude des LISA
class(bordeaux_lisa)
str(bordeaux_lisa, max.level=1)
summary(bordeaux_lisa)

mean(bordeaux_lisa[,1])
#La moyenne des LISA est bien proche du I de Moran global que nous avons trouvé ci-dessus 

table(bordeaux_lisa[,"Ii"] < 0)
#Sur les 758 entités, 153 ont un LISA négatif
#Le phénomène d'autocorrélation spatiale positive est donc confirmé
#Cependant, le nombre d'entités géographiques entourées d'entités aux revenus différents n'est pas non plus à négliger

###Visualisation des LISA sur la carte 
#Ajout de la variable au fond
bordeaux <- bordeaux %>% 
  mutate(LISA = bordeaux_lisa[,"Ii"])
#Spécification de la palette
pal <- rev(RColorBrewer::brewer.pal(8, "RdYlBu"))
#Visualisation 
plot(bordeaux["LISA"], breaks = c(-8.5,-1.2,-0.7,-0.1,0,0.1,0.7,1.2,8.5), pal = pal)

#Les LISA sont très élevés au Centre-Nord, Nord-Est et Sud-Est
#La visualisation confirme tout de même la présence de plusieurs entités géographiques entourées de revenus différents 

###Test sur la significativité 
#On créé une nouvelle variable spécifique à la p-valeur 
bordeaux <- bordeaux %>%
  mutate(LISA_PVAL = bordeaux_lisa[,5])

#Pour un niveau à 95%, on recherche les LISA significativement différents de zéro
table(bordeaux$LISA_PVAL < 0.05)
summary(bordeaux$LISA_PVAL)

#Visualisation de la p-valeur 
plot(bordeaux["LISA_PVAL"], breaks = c(0,0.01,0.05,0.1,1))

#Les zones où les p-valeurs sont les plus faibles correspondent bien aux zones identifiées ci-dessus (au moment de la visualisation des LISA)

###Pour aller plus loin 
#Nous avons esssayer de prendre en compte la multiplicité des test et d'ajuster la p-valeur en reprenant la méthode suggérée par le Manuel d'Analyse Spatiale
#On essaye pour les méthodes de BONFERRONI et de HOLM qui sont abordées dans le manuel
?p.adjust
#Bonferroni
p_val_ajustee_b<-p.adjust(bordeaux$LISA_PVAL, method = 'bonferroni')
summary(p_val_ajustee_b)
bordeaux <- bordeaux %>%
  mutate(LISA_PVAL_AJUSTEE_B = p_val_ajustee_b)
plot(bordeaux["LISA_PVAL_AJUSTEE_B"], breaks = c(0,0.01,0.05,0.1,1))
#Holm
p_val_ajustee_h<-p.adjust(bordeaux$LISA_PVAL, method = 'holm')
summary(p_val_ajustee_h)
bordeaux <- bordeaux %>%
  mutate(LISA_PVAL_AJUSTEE_H = p_val_ajustee_h)
plot(bordeaux["LISA_PVAL_AJUSTEE_H"], breaks = c(0,0.01,0.05,0.1,1))

#Les cartes obtenues sont les mêmes
#Cependant, elles différent de façon conséquente de la carte des p-valeurs non-ajustées représentée ci-dessus
#Les p-valeurs ajustées sont presques toutes très élevées, voire égale à 1
#La méthode est sans doute mal implémentée (ou ne convient fianlement pas à ce type d'observations)
#On peut cependant noter que le manuel indique que l'ajustement type Bonferroni diminue la probabilité d'identifier à tort de l'autocorrélation spatiale, mais augmente celle d'ignorer un cluster local
#Dans le cadre d'une étude, il faudrait donc réflechir aux risques que l'on souhaite privilégier 
```

